<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <title>Group Video Chat - Tugwemo</title>
  <link rel="icon" href="public/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="public/style.css">
  <link rel="stylesheet" href="public/videostyle.css">
</head>

<body>
  <!-- Header -->
  <header class="header">
    <div class="container">
      <div class="header-content">
        <img src="public/Tugwemo.png" alt="Tugwemo Logo" class="header-logo" onclick="window.location.href='/'">
        <div class="room-info">
          <span class="room-code-display">Room: <strong id="current-room-code">Loading...</strong></span>
          <span class="participant-count">Participants: <strong id="participant-count">1</strong></span>
        </div>
        <nav class="nav">
          <button class="btn leave-btn" onclick="leaveGroupRoom()">Leave Room</button>
        </nav>
      </div>
    </div>
  </header>

  <!-- Video Grid Section -->
  <div class="group-video-section">
    <div class="video-grid-container">
      <div class="video-grid" id="video-grid">
        <!-- Videos will be dynamically added here -->
        <!-- Default empty slots for 2x3 grid -->
        <div class="video-slot empty-slot" id="slot-1">
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        </div>
        <div class="video-slot empty-slot" id="slot-2">
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        </div>
        <div class="video-slot empty-slot" id="slot-3">
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        </div>
        <div class="video-slot empty-slot" id="slot-4">
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        </div>
        <div class="video-slot empty-slot" id="slot-5">
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        </div>
        <div class="video-slot empty-slot" id="slot-6">
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="group-controls">
    <button id="mute" class="btn control-btn mute">
      <span class="btn-icon">ðŸ”Š</span>
      <span class="btn-text">Mute</span>
    </button>
    <button id="video-toggle" class="btn control-btn video">
      <span class="btn-icon">ðŸ“¹</span>
      <span class="btn-text">Video</span>
    </button>
    <button id="share-code" class="btn control-btn share">
      <span class="btn-icon">ðŸ“‹</span>
      <span class="btn-text">Share Code</span>
    </button>
  </div>

  <!-- Chat Panel (Optional - can be toggled) -->
  <div class="chat-panel" id="chat-panel" style="display: none;">
    <div class="chat-header">
      <span class="chat-title">ðŸ’¬ Group Chat</span>
      <button class="chat-close" onclick="toggleChat()">&times;</button>
    </div>
    <div class="chat-messages" id="chat-messages"></div>
    <div class="chat-input">
      <input type="text" id="chat-input" placeholder="Type a message..." maxlength="200">
      <button id="send-message" class="btn-send">Send</button>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    // Global state
    let socket;
    let localStream;
    let peerConnections = new Map();
    let currentRoomCode = null;
    let isMuted = false;
    let isVideoOn = true;
    let participants = new Map();

    // Initialize when page loads
    window.addEventListener('load', () => {
      initGroupVideo();
    });

    function initGroupVideo() {
      // Get room code from localStorage
      currentRoomCode = localStorage.getItem('groupRoomCode');
      if (!currentRoomCode) {
        alert('No room code found. Redirecting to group page.');
        window.location.href = 'group.html';
        return;
      }

      // Update UI
      document.getElementById('current-room-code').textContent = currentRoomCode;

      // Initialize socket connection
      initSocket();

      // Initialize media
      initMedia();

      // Setup event listeners
      setupEventListeners();
    }

    function initSocket() {
      const backendUrl = window.location.hostname === 'localhost' ? 'http://localhost:8000' : 'https://tugwemo-backend.onrender.com';
      const token = localStorage.getItem('token');
      socket = io(backendUrl, {
        auth: {
          token: token
        }
      });

      socket.on('connect', () => {
        console.log('Connected to server');
        // Join the custom room
        socket.emit('join-custom-room', { roomCode: currentRoomCode });
      });

      socket.on('room-joined', (data) => {
        console.log('Joined room:', data);
        updateParticipantCount(data.participants);
      });

      socket.on('existing-participants', (data) => {
        console.log('Existing participants:', data.participants);
        // Add all existing participants to the video grid
        // Only create offers to participants with lower socket IDs to avoid conflicts
        data.participants.forEach(participant => {
          const shouldCreateOffer = socket.id > participant.socketId;
          addParticipant(participant.socketId, participant.userInfo, shouldCreateOffer);
        });
      });

      socket.on('user-joined', (data) => {
        console.log('User joined:', data);
        // Add new participant
        // Only create offer if our socket ID is higher (to avoid duplicate offers)
        const shouldCreateOffer = socket.id > data.socketId;
        addParticipant(data.socketId, data.userInfo, shouldCreateOffer);
        updateParticipantCount(data.participants);
      });

      socket.on('user-left', (data) => {
        console.log('User left:', data);
        removeParticipant(data.socketId);
        updateParticipantCount(data.participants);
      });

      socket.on('room-full', () => {
        alert('Room is full!');
        window.location.href = 'group.html';
      });

      // WebRTC signaling
      socket.on('webrtc-offer', handleOffer);
      socket.on('webrtc-answer', handleAnswer);
      socket.on('webrtc-ice', handleIceCandidate);

      // Chat messages
      socket.on('group-message', handleGroupMessage);
    }

    async function initMedia() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'user'
          }
        });

        // Add local video to first slot
        addLocalVideo();
      } catch (error) {
        console.error('Error accessing media:', error);
        alert('Unable to access camera/microphone');
      }
    }

    function addLocalVideo() {
      const slot1 = document.getElementById('slot-1');
      slot1.className = 'video-slot occupied-slot';
      slot1.innerHTML = `
        <video id="local-video" autoplay muted playsinline></video>
        <div class="video-label">You</div>
      `;
      document.getElementById('local-video').srcObject = localStream;
    }

    function addParticipant(socketId, userInfo, shouldCreateOffer = true) {
      if (participants.has(socketId) || socketId === socket.id) return;

      participants.set(socketId, { socketId, userInfo });

      // Find empty slot
      const emptySlots = document.querySelectorAll('.empty-slot');
      if (emptySlots.length > 0) {
        const slot = emptySlots[0];
        slot.className = 'video-slot occupied-slot';
        slot.innerHTML = `
          <video id="video-${socketId}" autoplay playsinline></video>
          <div class="video-label">${userInfo?.name || 'Anonymous'}</div>
        `;

        // Create peer connection
        createPeerConnection(socketId);

        // Only create offer if specified (for existing participants)
        if (shouldCreateOffer) {
          createOffer(socketId);
        }
      }
    }

    function removeParticipant(socketId) {
      participants.delete(socketId);

      // Find and clear the slot
      const videoElement = document.getElementById(`video-${socketId}`);
      if (videoElement) {
        const slot = videoElement.parentElement;
        slot.className = 'video-slot empty-slot';
        slot.innerHTML = `
          <div class="empty-slot-content">
            <div class="empty-icon">ðŸ“¹</div>
            <div class="empty-text">Waiting for participants...</div>
          </div>
        `;
      }

      // Close peer connection
      if (peerConnections.has(socketId)) {
        peerConnections.get(socketId).close();
        peerConnections.delete(socketId);
      }
    }

    function createPeerConnection(socketId) {
      const peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });

      peerConnections.set(socketId, peerConnection);

      // Add local stream tracks
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // Handle remote stream
      peerConnection.ontrack = (event) => {
        const remoteVideo = document.getElementById(`video-${socketId}`);
        if (remoteVideo && !remoteVideo.srcObject) {
          remoteVideo.srcObject = event.streams[0];
        }
      };

      // Handle ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('webrtc-ice', {
            targetSocketId: socketId,
            candidate: event.candidate
          });
        }
      };

      // Create offer if we're the initiator (only if not already created)
      // Offers are now created in addParticipant
    }

    async function createOffer(socketId) {
      const peerConnection = peerConnections.get(socketId);
      if (!peerConnection) return;

      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        socket.emit('webrtc-offer', {
          targetSocketId: socketId,
          offer: offer
        });
      } catch (error) {
        console.error('Error creating offer:', error);
      }
    }

    async function handleOffer(data) {
      const { fromSocketId, offer } = data;
      let peerConnection = peerConnections.get(fromSocketId);

      if (!peerConnection) {
        createPeerConnection(fromSocketId);
        peerConnection = peerConnections.get(fromSocketId);
      }

      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        socket.emit('webrtc-answer', {
          targetSocketId: fromSocketId,
          answer: answer
        });
      } catch (error) {
        console.error('Error handling offer:', error);
      }
    }

    async function handleAnswer(data) {
      const { fromSocketId, answer } = data;
      const peerConnection = peerConnections.get(fromSocketId);

      if (peerConnection) {
        try {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (error) {
          console.error('Error handling answer:', error);
        }
      }
    }

    async function handleIceCandidate(data) {
      const { fromSocketId, candidate } = data;
      const peerConnection = peerConnections.get(fromSocketId);

      if (peerConnection) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (error) {
          console.error('Error adding ICE candidate:', error);
        }
      }
    }

    function updateParticipantCount(count) {
      document.getElementById('participant-count').textContent = count;
    }

    function setupEventListeners() {
      // Control buttons
      document.getElementById('mute').addEventListener('click', toggleMute);
      document.getElementById('video-toggle').addEventListener('click', toggleVideo);
      document.getElementById('share-code').addEventListener('click', shareRoomCode);

      // Chat (if enabled)
      document.getElementById('send-message').addEventListener('click', sendMessage);
      document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') sendMessage();
      });
    }

    function toggleMute() {
      const audioTracks = localStream.getAudioTracks();
      audioTracks.forEach(track => {
        track.enabled = isMuted;
      });
      isMuted = !isMuted;

      const muteBtn = document.getElementById('mute');
      const icon = muteBtn.querySelector('.btn-icon');
      const text = muteBtn.querySelector('.btn-text');

      if (isMuted) {
        icon.textContent = 'ðŸ”‡';
        text.textContent = 'Unmute';
        muteBtn.classList.add('muted');
      } else {
        icon.textContent = 'ðŸ”Š';
        text.textContent = 'Mute';
        muteBtn.classList.remove('muted');
      }
    }

    function toggleVideo() {
      const videoTracks = localStream.getVideoTracks();
      videoTracks.forEach(track => {
        track.enabled = !isVideoOn;
      });
      isVideoOn = !isVideoOn;

      const videoBtn = document.getElementById('video-toggle');
      const icon = videoBtn.querySelector('.btn-icon');
      const text = videoBtn.querySelector('.btn-text');

      if (!isVideoOn) {
        icon.textContent = 'ðŸ“·';
        text.textContent = 'Turn On';
        videoBtn.classList.add('off');
      } else {
        icon.textContent = 'ðŸ“¹';
        text.textContent = 'Video';
        videoBtn.classList.remove('off');
      }
    }

    function shareRoomCode() {
      const code = currentRoomCode;
      const shareText = `Join my Tugwemo group video chat! Room code: ${code}`;

      if (navigator.share) {
        navigator.share({
          title: 'Tugwemo Group Chat',
          text: shareText,
          url: window.location.href
        });
      } else {
        // Fallback: copy to clipboard
        navigator.clipboard.writeText(shareText).then(() => {
          alert('Room code copied to clipboard!');
        });
      }
    }

    function sendMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      if (message) {
        socket.emit('group-message', {
          roomCode: currentRoomCode,
          message: message
        });
        input.value = '';
        displayMessage('You', message);
      }
    }

    function handleGroupMessage(data) {
      displayMessage(data.sender, data.message);
    }

    function displayMessage(sender, message) {
      const messagesDiv = document.getElementById('chat-messages');
      const messageEl = document.createElement('div');
      messageEl.className = 'chat-message';
      messageEl.innerHTML = `<strong>${sender}:</strong> ${message}`;
      messagesDiv.appendChild(messageEl);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function toggleChat() {
      const chatPanel = document.getElementById('chat-panel');
      chatPanel.style.display = chatPanel.style.display === 'none' ? 'block' : 'none';
    }

    function leaveGroupRoom() {
      if (confirm('Are you sure you want to leave the room?')) {
        // Close all peer connections
        peerConnections.forEach(pc => pc.close());
        peerConnections.clear();

        // Stop local stream
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
        }

        // Leave socket room
        socket.emit('leave-custom-room', { roomCode: currentRoomCode });

        // Clear localStorage and redirect
        localStorage.removeItem('groupRoomCode');
        window.location.href = 'group.html';
      }
    }

    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      peerConnections.forEach(pc => pc.close());
    });
  </script>

  <style>
    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 0;
    }

    .header-logo {
      height: 40px;
      cursor: pointer;
    }

    .room-info {
      display: flex;
      gap: 2rem;
      color: #333;
      font-size: 0.9rem;
    }

    .leave-btn {
      background: #e74c3c;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .leave-btn:hover {
      background: #c0392b;
    }

    .group-video-section {
      min-height: calc(100vh - 160px);
      background: #f8f9fa;
      padding: 2rem 0;
    }

    .video-grid-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    .video-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 1rem;
      aspect-ratio: 3/2;
      max-height: 70vh;
    }

    .video-slot {
      background: #000;
      border-radius: 1rem;
      overflow: hidden;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 200px;
    }

    .empty-slot {
      background: rgba(0, 0, 0, 0.1);
      border: 2px dashed #ccc;
    }

    .empty-slot-content {
      text-align: center;
      color: #666;
    }

    .empty-icon {
      font-size: 3rem;
      margin-bottom: 0.5rem;
    }

    .empty-text {
      font-size: 0.9rem;
    }

    .occupied-slot video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .video-label {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .group-controls {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 1rem;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem;
      border-radius: 2rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      z-index: 100;
    }

    .control-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 0.5rem;
      transition: all 0.3s ease;
      min-width: 60px;
    }

    .control-btn:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .control-btn.muted {
      background: #e74c3c;
      color: white;
    }

    .control-btn.off {
      background: #e74c3c;
      color: white;
    }

    .btn-icon {
      font-size: 1.5rem;
    }

    .btn-text {
      font-size: 0.8rem;
      font-weight: 500;
    }

    .chat-panel {
      position: fixed;
      right: 2rem;
      top: 50%;
      transform: translateY(-50%);
      width: 300px;
      height: 400px;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      z-index: 100;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid #eee;
      background: #f8f9fa;
      border-radius: 1rem 1rem 0 0;
    }

    .chat-title {
      font-weight: 600;
      color: #333;
    }

    .chat-close {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: #666;
    }

    .chat-messages {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .chat-message {
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 0.5rem;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .chat-input {
      display: flex;
      padding: 1rem;
      border-top: 1px solid #eee;
      gap: 0.5rem;
    }

    .chat-input input {
      flex: 1;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 0.25rem;
      font-size: 0.9rem;
    }

    .btn-send {
      background: #667eea;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 0.25rem;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .btn-send:hover {
      background: #5a6fd8;
    }

    @media (max-width: 768px) {
      .video-grid {
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(3, 1fr);
        aspect-ratio: 2/3;
      }

      .group-controls {
        bottom: 1rem;
        padding: 0.75rem;
        gap: 0.5rem;
      }

      .control-btn {
        min-width: 50px;
        padding: 0.25rem;
      }

      .chat-panel {
        width: 90vw;
        height: 300px;
        right: 1rem;
        left: 1rem;
        right: auto;
      }

      .room-info {
        flex-direction: column;
        gap: 0.5rem;
        text-align: center;
      }
    }
  </style>
</body>
</html>
